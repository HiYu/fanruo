<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>凡 若</title>
  
  <subtitle>初心 读书 知新 生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m.fanruo.net/"/>
  <updated>2020-05-01T14:35:37.974Z</updated>
  <id>https://m.fanruo.net/</id>
  
  <author>
    <name>Frank Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis 源码源文件文件说明</title>
    <link href="https://m.fanruo.net/2020/05/01/redis-%E6%BA%90%E7%A0%81%E6%BA%90%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E/"/>
    <id>https://m.fanruo.net/2020/05/01/redis-源码源文件文件说明/</id>
    <published>2020-05-01T14:34:38.000Z</published>
    <updated>2020-05-01T14:35:37.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis-源码源文件说明"><a href="#redis-源码源文件说明" class="headerlink" title="redis 源码源文件说明"></a>redis 源码源文件说明</h1><table><thead><tr><th>分类</th><th>源文件</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>数据结构/编码</td><td>adlist.c, adlist.h</td><td>双端链表数据结构的实现。</td><td></td></tr><tr><td>数据结构/编码</td><td>quicklist.c, quicklist.h</td><td>快表实现</td><td></td></tr><tr><td>数据结构/编码</td><td>listpack.c, listpack.h, listpack_malloc.h</td><td>5.0 新增liskpack实现</td><td></td></tr><tr><td>数据结构/编码</td><td>rax.c, rax.h, rax_malloc.h</td><td>基数树实现</td><td></td></tr><tr><td>数据结构/编码</td><td>dict.c, dict.h</td><td>字典数据结构的实现。</td><td></td></tr><tr><td>数据结构/编码</td><td>intset.c, intset.h</td><td>intset 数据结构实现</td><td></td></tr><tr><td>数据结构/编码</td><td>sds.c, sds.h, sdsalloc.h</td><td>sds 字符串实现</td><td></td></tr><tr><td>数据结构/编码</td><td>ziplist.c, ziplist.h</td><td>压缩表实现</td><td></td></tr><tr><td>数据结构/编码</td><td>zipmap.c, zipmap.h</td><td>ZIPMAP 数据结构的实现，在 Redis 2.6 以前用与优化 HASH 类型， Redis 2.6 开始已经废弃。</td><td></td></tr><tr><td>数据结构/编码</td><td>stream.h</td><td>5.0 新增stream数据结构实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_string.c</td><td>string 数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_hash.c</td><td>hash 数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_list.c</td><td>list 数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_set.c</td><td>set 数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_stream.c</td><td>stream 数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>t_zset.c</td><td>数据类型实现</td><td></td></tr><tr><td>数据类型/功能</td><td>geo.c, geo.h, geohash.c, geohash.h, geohash_helper.c, geohash_helper.h</td><td>地理信息相关操作实现</td><td></td></tr><tr><td>数据类型/功能</td><td>hyperloglog.c</td><td>hyperloglog 相关操作实现</td><td></td></tr><tr><td>数据类型/功能</td><td>pubsub.c</td><td>消息队列实现</td><td></td></tr><tr><td>数据类型/功能</td><td>bitops.c</td><td>位操作相关实现</td><td></td></tr><tr><td>数据类型/功能</td><td>scripting.c</td><td>lua脚本功能实现</td><td></td></tr><tr><td>数据类型/功能</td><td>sort.c</td><td>SORT命令的实现</td><td></td></tr><tr><td>数据类型/功能</td><td>multi.c</td><td>Redis 的事务实现。</td><td></td></tr><tr><td>数据类型/功能</td><td>blocked.c</td><td>用于实现 BLPOP 命令和 WAIT 命令的阻塞效果。</td><td></td></tr><tr><td>数据类型/功能</td><td>lolwut5.c</td><td>5.0 新增的酷炫命令</td><td></td></tr><tr><td>数据类型/功能</td><td>lolwut.c</td><td>5.0 新增的酷炫命令</td><td></td></tr><tr><td>事件处理器/IO</td><td>ae.c, ae.h, ae_epoll.c, ae_evport.c, ae_kqueue.c, ae_select.c</td><td>事件处理器，以及各个具体实现</td><td></td></tr><tr><td>事件处理器/IO</td><td>rio.c, rio.h</td><td>Redis 对文件 I/O 函数的包装， 在普通 I/O 函数的基础上增加了显式缓存、以及计算校验和等功能。</td><td></td></tr><tr><td>事件处理器/IO</td><td>bio.c, bio.h</td><td>Redis 的后台 I/O 程序，用于将 I/O 操作放到子线程里面执行， 减少 I/O 操作对主线程的阻塞。</td><td></td></tr><tr><td>事件处理器/IO</td><td>syncio.c</td><td>同步IO实现</td><td></td></tr><tr><td>事件处理器/IO</td><td>anet.c, anet.h</td><td>Redis 的异步网络框架，内容主要为对 socket 库的包装。</td><td></td></tr><tr><td>事件处理器/IO</td><td>networking.c</td><td>Redis 的客户端网络操作库， 用于实现命令请求接收、发送命令回复等工作， 文件中的函数大多为 write 、 read 、 close 等函数的包装， 以及各种协议的分析和构建函数。</td><td></td></tr><tr><td>数据库实现</td><td>object.c</td><td>Redis 的对象系统实现。</td><td></td></tr><tr><td>数据库实现</td><td>db.c</td><td>数据库实现。</td><td></td></tr><tr><td>数据库实现</td><td>notify.c</td><td>Redis 的数据库通知实现。</td><td></td></tr><tr><td>数据库实现</td><td>evict.c</td><td>LRU 数据淘汰机制</td><td></td></tr><tr><td>数据类型/功能</td><td>expire.c</td><td>过期机制实现</td><td></td></tr><tr><td>服务端&amp;客户端</td><td>server.c, server.h</td><td>服务端实现</td><td></td></tr><tr><td>服务端&amp;客户端</td><td>config.c, config.h</td><td>Redis 的配置管理实现，负责读取并分析配置文件， 然后根据这些配置修改 Redis 服务器的各个选项。</td><td></td></tr><tr><td>服务端&amp;客户端</td><td>redis-cli.c</td><td>客户端实现</td><td></td></tr><tr><td>持久化</td><td>aof.c</td><td>aof 实现</td><td></td></tr><tr><td>持久化</td><td>redis-check-aof.c</td><td>AOF 文件的合法性检查程序。</td><td></td></tr><tr><td>持久化</td><td>rdb.c, rdb.h</td><td>RDB 功能实现</td><td></td></tr><tr><td>持久化</td><td>redis-check-rdb.c</td><td>RDB 文件的合法性检查程序。</td><td></td></tr><tr><td>持久化</td><td>childinfo.c</td><td>进程处理，rdb或aof子进程工作分离</td><td></td></tr><tr><td>多机支持</td><td>replication.c</td><td>主从复制实现</td><td></td></tr><tr><td>多机支持</td><td>sentinel.c</td><td>哨兵功能实现</td><td></td></tr><tr><td>多机支持</td><td>cluster.c, cluster.h</td><td>集群功能实现</td><td></td></tr><tr><td>多机支持</td><td>redis-trib.rb</td><td>集群管理功能实现</td><td></td></tr><tr><td>监控相关</td><td>slowlog.c, slowlog.h</td><td>慢日志</td><td></td></tr><tr><td>监控相关</td><td>latency.c, latency.h</td><td>延迟监控</td><td></td></tr><tr><td>监控相关</td><td>sparkline.c, sparkline.h</td><td>微线图功能实现</td><td></td></tr><tr><td>工具功能</td><td>util.c, util.h</td><td>工具类函数集合</td><td></td></tr><tr><td>工具功能</td><td>siphash.c</td><td>Redis 4.0 &amp; 5.0, 采用的是 SipHash 哈希算法</td><td></td></tr><tr><td>工具功能</td><td>pqsort.c, pqsort.h</td><td>快速排序（QuickSort）算法的实现</td><td></td></tr><tr><td>工具功能</td><td>lzf_c.c, lzf_d.c, lzf.h, lzfP.h</td><td>Redis 对字符串和 RDB 文件进行压缩时使用的 LZF 压缩算法的实现。</td><td></td></tr><tr><td>工具功能</td><td>module.c, redismodule.h</td><td>支持用户自定义module</td><td></td></tr><tr><td>工具功能</td><td>modules</td><td>module demo</td><td></td></tr><tr><td>工具功能</td><td>endianconv.c, endianconv.h</td><td>二进制的大端、小端转换函数。</td><td></td></tr><tr><td>工具功能</td><td>sha1.c, sha1.h</td><td>SHA1 校验和计算函数。</td><td></td></tr><tr><td>工具功能</td><td>crc16.c, crc64.c, crc64.h</td><td>计算 CRC 校验和。</td><td></td></tr><tr><td>工具功能</td><td>rand.c, rand.h</td><td>随机数实现</td><td></td></tr><tr><td>工具功能</td><td>localtime.c</td><td>时间功能实现</td><td></td></tr><tr><td>工具功能</td><td>setproctitle.c</td><td>进程环境设置函数</td><td></td></tr><tr><td>工具功能</td><td>atomicvar.h</td><td>原子计数实现</td><td></td></tr><tr><td>内存管理</td><td>zmalloc.c, zmalloc.h</td><td></td><td></td></tr><tr><td>内存管理</td><td>defrag.c</td><td>内存碎片整理</td><td></td></tr><tr><td>内存管理</td><td>lazyfree.c</td><td>redis 4.0 引入了lazyfree的机制，它可以将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</td><td></td></tr><tr><td>调试/测试/其他</td><td>valgrind.sup</td><td>valgrind 的suppression文件。</td><td></td></tr><tr><td>调试/测试/其他</td><td>asciilogo.h</td><td>ascii logo</td><td></td></tr><tr><td>调试/测试/其他</td><td>version.h</td><td>版本</td><td></td></tr><tr><td>调试/测试/其他</td><td>release.c</td><td>记录和生成 Redis 的释出版本信息。</td><td></td></tr><tr><td>调试/测试/其他</td><td>testhelp.h</td><td>测试辅助宏。</td><td></td></tr><tr><td>调试/测试/其他</td><td>debug.c</td><td>调试实现。</td><td></td></tr><tr><td>调试/测试/其他</td><td>debugmacro.h</td><td>调试宏定义实现</td><td></td></tr><tr><td>调试/测试/其他</td><td>redis-benchmark.c</td><td>redis benchmark 测试工具</td><td></td></tr><tr><td>调试/测试/其他</td><td>memtest.c</td><td>内存测试。</td><td></td></tr><tr><td>调试/测试/其他</td><td>redisassert.h</td><td>Redis 自建的断言系统。</td><td></td></tr><tr><td>调试/测试/其他</td><td>help.h</td><td>utils/generate-command-help.rb 程序自动生成的命令帮助信息。</td><td></td></tr><tr><td>调试/测试/其他</td><td>mkreleasehdr.sh</td><td>用于生成释出信息的脚本。</td><td></td></tr><tr><td>调试/测试/其他</td><td>solarisfixes.h</td><td>针对 Solaris 系统的补丁。</td><td></td></tr><tr><td>调试/测试/其他</td><td>fmacros.h</td><td>一些移植性方面的宏。</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis-源码源文件说明&quot;&gt;&lt;a href=&quot;#redis-源码源文件说明&quot; class=&quot;headerlink&quot; title=&quot;redis 源码源文件说明&quot;&gt;&lt;/a&gt;redis 源码源文件说明&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/
      
    
    </summary>
    
      <category term="源码阅读" scheme="https://m.fanruo.net/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="redis" scheme="https://m.fanruo.net/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/redis/"/>
    
    
      <category term="源码阅读" scheme="https://m.fanruo.net/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
      <category term="redis" scheme="https://m.fanruo.net/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】26. 链表-链表中倒数第k个节点</title>
    <link href="https://m.fanruo.net/2020/03/14/%E3%80%90leetcode%E3%80%9126-%E9%93%BE%E8%A1%A8-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://m.fanruo.net/2020/03/14/【leetcode】26-链表-链表中倒数第k个节点/</id>
    <published>2020-03-14T15:17:35.000Z</published>
    <updated>2020-03-14T15:18:34.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>:</p><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题典型的双指针题目：</p><ol><li>设指针<code>rp</code>、<code>lp</code>都指向<code>head</code>,</li><li><code>rp</code>先走<code>k</code>步</li><li><code>rp</code>、<code>lp</code> 同步移动</li><li>到<code>rp</code>指向链表尾后<code>NULL</code>的时候，<code>lp</code>即是倒数第<code>k</code>个节点</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *lp = head, *rp = head;</span><br><span class="line">        <span class="keyword">while</span> (rp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rp = rp-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp = lp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述算法，可以进一步优化，<code>rp</code>只先走<code>k-1</code>步，最后<code>rp</code>指向链表的最后一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *lp = head, *rp = head;</span><br><span class="line">        <span class="keyword">while</span> (rp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            rp = rp-&gt;next;<span class="comment">// 结束时，rp是最后一个节点，而非NULL</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp = lp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="链表" scheme="https://m.fanruo.net/categories/leetcode/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="链表" scheme="https://m.fanruo.net/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】25. 数组-旋转数组的最小数字</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9125-%E6%95%B0%E7%BB%84-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】25-数组-旋转数组的最小数字/</id>
    <published>2020-03-08T14:24:30.000Z</published>
    <updated>2020-03-08T14:29:51.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。<br>难易程度：<em>easy</em></p><p><strong>示例 1</strong>：</p><blockquote><p>输入：[3,4,5,1,2]<br>输出：1</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：[2,2,2,0,1]<br>输出：0</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，题目中给出的数组是部分有序。最小的元素就是<strong>旋转点</strong>：</p><ol><li>前后元素都比他大</li><li>前边的子数组是递增的</li><li>后边的子数组是递增的</li></ol><p>因此，直观的解法就是遍历，找到第一个位置：<code>numbers[l] &lt; numbers[r]</code>。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] &gt;= numbers[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>题意已经明确，原始数组是由有序数组旋转生成，设最小值的索引为<code>mid</code>，则<code>[0, mid)</code>和<code>[mid, size)</code>是两个有序数组。查找最小值本身就是搜索问题。本题题意抽取出如下两点：</p><ol><li>有序</li><li>查找</li></ol><p>因此，可以考虑二分搜索算法，判断条件如下;</p><ol><li><code>numbers[mid] &gt; numbers</code> , 则<code>l = mid + 1</code></li><li><code>numbers[mid] &lt; numbers</code>, 则<code>r = mid</code></li><li><code>numbers[mid] == numbers</code> ,特殊的点就在这儿，此时，最小值只能在<code>[l, r)</code>，因此<code>r--</code></li></ol><p><strong>时间复杂度</strong>：O(logN)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = ((r - l) &gt;&gt; <span class="number">1</span>) + l;</span><br><span class="line">            <span class="keyword">if</span> (numbers[mid] &gt; numbers[r]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; numbers[r]) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="搜索" scheme="https://m.fanruo.net/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】24. 数学-青蛙跳台阶问题</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9124-%E6%95%B0%E5%AD%A6-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】24-数学-青蛙跳台阶问题/</id>
    <published>2020-03-08T14:24:17.000Z</published>
    <updated>2020-03-08T14:31:12.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>难易程度：<em>easy</em></p><p><strong>示例 1</strong>：</p><blockquote><p>输入：n = 2<br>输出：2</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：n = 7<br>输出：21</p></blockquote><p><strong>提示</strong>：</p><blockquote><p>0 &lt;= n &lt;= 100</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先枚举几个结果：</p><blockquote><p>当 n = 0； 需要跳 1 次<br>当 n = 1； 需要跳 1 次<br>当 n = 2； 需要跳 2 次<br>当 n = 3； 需要跳 3 次<br>当 n = 4； 需要跳 5 次<br>当 n = 5； 需要跳 8 次<br>…</p></blockquote><p>如果青蛙要跳到第<code>n</code>级台阶，则它要么从<code>n-1</code>级台阶跳<code>1</code>级跳，要么从<code>n-2</code>级台阶跳<code>2</code>级跳。设跳到<code>n</code>级台阶有<code>dp[n]</code>种方法，则<code>dp[n] = dp[n-1]+dp[n-2]</code>。<br>至此，会发现其实就是一个斐波那契数列的变种，不同点就是<code>dp[0] = 1</code>，而斐波那契数列第0个数是0.</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n0 = <span class="number">1</span>, n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = n1;</span><br><span class="line">            n1 = (n0 + n1) % <span class="number">1000000007</span>;</span><br><span class="line">            n0 = tmp;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;br&gt;答案需要取模 1e9+7（1000
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数学" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数学" scheme="https://m.fanruo.net/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】22. 位操作-二进制中1的个数</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9122-%E4%BD%8D%E6%93%8D%E4%BD%9C-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】22-位操作-二进制中1的个数/</id>
    <published>2020-03-08T14:23:53.000Z</published>
    <updated>2020-03-08T14:30:57.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。<br>难易程度：<em>easy</em></p><p><strong>示例 1</strong>：</p><blockquote><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p></blockquote><p><strong>示例 3</strong>：</p><blockquote><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题一种暴力的解法就是循环判断<code>n</code>的每一位是否为<code>1</code>。<br><strong>时间复杂度</strong>：O(1)，可以算作O(1)的时间复杂度了，毕竟循环32次就行了。<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            cnt += n &amp; <span class="number">1</span>;<span class="comment">//只判断最后一位</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><code>n-1</code>会将<code>n</code>最左侧的<code>1</code>变成<code>0</code>，同最左侧的<code>0</code>变成<code>1</code>。如：</p><blockquote><p>n:       00000000000000000000000000001011<br>n-1:     00000000000000000000000000001010<br>n&amp;(n-1):  00000000000000000000000000001010<br>n:       00000000000000000000000000001000<br>n-1:     00000000000000000000000000000111<br>n&amp;(n-1):  00000000000000000000000000000000</p></blockquote><p>从上面可以看出，n&amp;(n-1)可以消去<code>n</code>最左侧的<code>1</code>,从而使得遍历次数为<code>1</code>的个数。<br><strong>时间复杂度</strong>：O(1)，可以算作O(1)的时间复杂度了，循环最多32次就行了。<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            n &amp;=(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="位操作" scheme="https://m.fanruo.net/categories/leetcode/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="位操作" scheme="https://m.fanruo.net/tags/%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】20. 序列-和为s的连续正数序列</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9120-%E5%BA%8F%E5%88%97-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】20-序列-和为s的连续正数序列/</id>
    <published>2020-03-08T14:23:39.000Z</published>
    <updated>2020-03-08T14:25:50.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：target = 9<br>输出：[[2,3,4],[4,5]]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：target = 15<br>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p></blockquote><blockquote><p>限制：<br>1 &lt;= target &lt;= 10^5</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题方法比较多，如暴力遍历，双指针法等，这里只介绍利用数学公式来求解的方法。<br>本题本质上是序列求和问题，此类问题的一个经典问题就是求<code>1,...,100</code>这100个数之和。当年高斯使用的方法就是<code>(1+100)*100/2</code>。</p><p>设<code>s &lt; x</code> 且<code>s,...,x</code>这<code>(x - s + 1)</code>个连续整数之和为<code>target</code>。那么，有<code>(s + x)*(x -s + 1) == 2 * target</code>,即存在一元二次方程:<br><code>x^2 + x + s*(1-s) - 2*target = 0</code>。<br>根据韦达定理解得：<br><code>x = (sqrt(1-4(s*(1-s) - 2*target)) - 1) / 2</code><br>最终本题转变成有多少个<code>[s, x]</code>区间的问题，即枚举<code>s</code>的情况下求解一元二次方程:<code>x^2 + x + s*(1-s) - 2*target = 0</code> 整数正值的问题。</p><p><strong>时间复杂度</strong>：O(N)，由于枚举以后只需要 O(1)的时间判断，所以时间复杂度为枚举起点的复杂度O(target/2) 。<br><strong>空间复杂度</strong>：O(1) ，除了答案数组只需要常数的空间存放若干变量。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 题中要求至少含有两个数，所以s最大为target-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt;= target / <span class="number">2</span>; s++) &#123;</span><br><span class="line">            <span class="comment">// 主要这里s*(1-s)可能超过MAX_INT，因此同乘以1ll来提升类型，下同</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> d = <span class="number">1</span> - <span class="number">4</span>*(<span class="number">1l</span>l * s*(<span class="number">1</span> - s) - <span class="number">2</span> * target);</span><br><span class="line">            <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sqrt_d = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(d);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1l</span>l * sqrt_d * sqrt_d == d &amp;&amp; (sqrt_d - <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= (sqrt_d - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                    tmp.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。&lt;br&gt;序列内的数字由小到大排列，不同序列按
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="序列" scheme="https://m.fanruo.net/categories/leetcode/%E5%BA%8F%E5%88%97/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="序列" scheme="https://m.fanruo.net/tags/%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】21. 序列-和为s的两个数字</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9121-%E5%BA%8F%E5%88%97-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】21-序列-和为s的两个数字/</id>
    <published>2020-03-08T14:21:28.000Z</published>
    <updated>2020-03-08T14:30:52.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。<br>难易程度：<em>easy</em></p><p><strong>示例 1</strong>：</p><blockquote><p>输入：nums = [2,7,11,15], target = 9<br>输出：[2,7] 或者 [7,2]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：nums = [10,26,30,31,47,60], target = 40<br>输出：[10,30] 或者 [30,10]</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^6</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题和《【leetcode】5. 数组-两数之和》列数，不通的地方是本题给出的数组是递增有序的。因此可以利用这条件来进行优化求解。<br>基本方法是利用双指针法，遍历求和。设有两个指针（下标）<code>int left = 0, right = nums.size() - 1;</code> 循环求解<code>um = nums[left] + nums[right];</code></p><ol><li>如果 <code>sum == target</code> 则返回对应下标元素</li><li>如果 <code>sum &lt; target</code> 则<code>left++</code></li><li>否则 <code>rigth--</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                res.push_back(nums[left]);</span><br><span class="line">                res.push_back(nums[right]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。&lt;br&gt;难易程度
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="序列" scheme="https://m.fanruo.net/categories/leetcode/%E5%BA%8F%E5%88%97/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="序列" scheme="https://m.fanruo.net/tags/%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】23. 数学-斐波那契数列</title>
    <link href="https://m.fanruo.net/2020/03/08/%E3%80%90leetcode%E3%80%9123-%E6%95%B0%E5%AD%A6-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://m.fanruo.net/2020/03/08/【leetcode】23-数学-斐波那契数列/</id>
    <published>2020-03-08T14:19:20.000Z</published>
    <updated>2020-03-09T15:46:25.154Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br>难易程度：<em>easy</em></p><p><strong>示例 1</strong>：</p><blockquote><p>输入：n = 2<br>输出：1</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：n = 5<br>输出：5</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题是经典的递归算法示例：<br>结束条件：<code>F(0) = 0, F(1) = 1</code><br>递归公式：<code>F(N) = F(N - 1) + F(N - 2)</code></p><p><strong>时间复杂度</strong>：O(N^2)<br><strong>空间复杂度</strong>：O(N)</p><p>ps:时间复杂度太高了，leetcode超时了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> ||n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题也是动态规划的经典示例。</p><ol><li>状态定义：设dp为一维数组，其中dp[i]的值代表斐波那契数列第i个数字。</li><li>转移方程：<code>dp[i + 1] = dp[i] + dp[i - 1]</code>，即对应数列定义<code>f(n + 1) = f(n) + f(n - 1)</code>；</li><li>初始状态：<code>dp[0] = 0, dp[1] = 1</code>，即初始化前两个数字；</li><li>返回值： <code>dp[n]</code>，即斐波那契数列的第<code>n</code>个数字.</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.push_back(<span class="number">0</span>);</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp.push_back((dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]) % <span class="number">1000000007</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>经典的动态规划方法较递归方法时间复杂度有所优化，但空间复杂度并没有优化。从动态规划方法中转移方程我们只用到了<code>dp[i + 1]</code>，<code>dp[i]</code>，<code>dp[i - 1]</code>三个元素，因此，我们只需要三个变量<code>fibn</code>，<code>fib1</code>，<code>fib2</code>即可，从而将空间复杂度降低到O(1)。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> fib1 = <span class="number">0</span>, fib2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> fibn = (fib1 + fib2) % <span class="number">1000000007</span>;</span><br><span class="line">            fib1 = fib2;</span><br><span class="line">            fib2 = fibn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;br&gt;F(0) = 0,   F(1) 
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数学" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数学" scheme="https://m.fanruo.net/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】19. 栈&amp;队列-队列的最大值</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9119-%E6%A0%88-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】19-栈-队列-队列的最大值/</id>
    <published>2020-02-28T14:33:41.000Z</published>
    <updated>2020-02-28T14:34:20.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>难易程度:<strong>Medium</strong></p><p><strong>示例 1</strong>：</p><blockquote><p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>1 &lt;= value &lt;= 10^5</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题和<strong>包含min函数的栈</strong>有点类似，但是要复杂很多。因为栈是在列表的异端操作，在<code>push</code>和<code>pop</code>操作时能够决定当前栈的最大值最小值。而队列<code>pop</code>和<code>back</code>操作是在列表的两端操作，因此队列在不同状态下的最值是变动的。</p><p>设有队列：<code>[8,3,5,4,1,2]</code><br>则最大值队列：<code>[8,5,4,2]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 0; max = 8; [8]</span><br><span class="line">i = 1; max = 5; [8,5]</span><br><span class="line">i = 2; max = 5; [8,5]</span><br><span class="line">i = 3; max = 4; [8,5,4]</span><br><span class="line">i = 4; max = 2; [8,5,4,2]</span><br><span class="line">i = 5; max = 2; [8,5,4,2]</span><br></pre></td></tr></table></figure><p>假设上述队列中加入新元素<code>9</code>,则最大值对列：<code>[9]</code><br>也即，队列中每个位置<code>i</code>的对应最大值<code>max</code>是索引区间<code>[i, n]</code>之间的最大值，因此，最大值队列是一个单调递减队列。因此，当有元素入队列的时候，需要逆序遍历更新最大值队列。</p><p>说明：1 &lt;= value &lt;= 10^5也算是常数时间了和队列长度，操作次数无关。</p><p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">        q = <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        max = <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!max.empty() &amp;&amp; value &gt; max.back()) &#123;</span><br><span class="line">            max.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        max.push_back(value);</span><br><span class="line">        q.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (res == max.front()) &#123;</span><br><span class="line">            max.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue* obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;max_value();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/categories/leetcode/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】18.栈&amp;队列-用两个栈实现队列</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9118-%E6%A0%88-%E9%98%9F%E5%88%97-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】18-栈-队列-用两个栈实现队列/</id>
    <published>2020-02-28T14:32:18.000Z</published>
    <updated>2020-02-28T14:34:23.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p></blockquote><p><strong>提示</strong>：</p><blockquote><p>1 &lt;= values &lt;= 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先明确，<strong>栈</strong>的特点是<strong>先进后出</strong>；<strong>队列</strong>的特点是<strong>先进先出</strong>。<br>要想用栈实现队列的特性，必须将最先进入的元素放在栈顶、最后放入的元素放在栈低。如何操作呢？题中给出的是<strong>两个栈实现一个队列</strong>，这时候，我们就需要利用另外一个栈了，假设我们有两个栈<code>stack1</code>和<code>stack2</code>，设<code>stack1</code>为操作栈，<code>stack2</code>为辅助栈。将一个元素加入到<code>stack1</code>中，我们可以借助<code>stack2</code>：</p><ol><li>如果<code>stack1</code>为空，则直接将元素<code>value</code> <code>push</code>到<code>stack1</code>中，这时<code>stack1</code>栈顶&amp;栈低是同一个元素</li><li>如果<code>stack1</code>不为空，则将<code>stack1</code>中的元素一次<code>push</code>到<code>stack2</code>中，此时，<code>stack1</code>为空，新元素<code>value</code> <code>push</code>到<code>stack1</code>中</li><li>将<code>stack2</code>中的元素写回<code>stack1</code>, <code>stack2</code>此次写入辅助使命完成。</li></ol><p>上面描述了写入流程，那么读取呢？更简单，直接正常操作<code>stack1</code>即可。</p><p>另外，可以维护一个队列长度变量<code>len</code>可以<code>O(1)</code>时间获取队列长度用于判断队列是否为空。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        stack1 = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        stack2 = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            stack1.push(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack1.push(value);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                stack1.push(stack2.top());</span><br><span class="line">                stack2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res = stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue* obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="队列" scheme="https://m.fanruo.net/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】17. 栈&amp;队列-包含min函数的栈</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9117-%E6%A0%88-%E9%98%9F%E5%88%97-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】17-栈-队列-包含min函数的栈/</id>
    <published>2020-02-28T14:30:54.000Z</published>
    <updated>2020-02-28T14:34:26.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(<span class="number">-2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(<span class="number">-3</span>);</span><br><span class="line">minStack.min();  <span class="comment">// --&gt; 返回 -3.</span></span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();    <span class="comment">//  --&gt; 返回 0.</span></span><br><span class="line">minStack.min();   <span class="comment">//--&gt; 返回 -2.</span></span><br></pre></td></tr></table></figure><p><strong>提示</strong>：</p><blockquote><p>各函数的调用总次数不超过 20000 次</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于队列有<code>先进先出</code>特性，对于队列<code>s</code>来说每次<code>push</code>或者<code>pop</code>一个元素都可能改变栈<code>s</code>的最小值<code>m</code>。</p><ol><li><code>push</code>一个元素<code>x</code>，如果<code>x &lt; m</code>, 则将<code>m</code>先入栈以保留当前栈的最小值，同时<code>m = x</code></li><li><code>push</code>新元素<code>x</code>入队列</li><li>当<code>pop</code>一个元素时，首先判断<code>s.top() == m</code>，如果成立，按照步骤1、2说明下一个元素是专门存的最小元素，需要同时<code>pop</code>出来</li><li>否则，直接<code>pop</code>就行</li><li><code>top</code>时正常<code>top</code>就行</li></ol><p><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        s = <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        m = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= m) &#123;</span><br><span class="line">            s.push(m);<span class="comment">// 保存插入前的最小值</span></span><br><span class="line">            m = x;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() == m) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">            m = s.top();<span class="comment">// 取出pop后的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">         s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/categories/leetcode/%E6%A0%88/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="栈" scheme="https://m.fanruo.net/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】16. 字符串-翻转单词顺序</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9116-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】16-字符串-翻转单词顺序/</id>
    <published>2020-02-28T14:30:11.000Z</published>
    <updated>2020-02-28T14:34:28.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入: “the sky is blue”<br>输出: “blue is sky the”</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p></blockquote><p><strong>示例 3</strong>：</p><blockquote><p>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><p><strong>说明</strong>：</p><blockquote><p>无空格字符构成一个单词。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题最直观的做法就是遍历整个字符串<code>s</code>，切出每个单词，然后<code>头插法</code>将切出的单词拼接为一个新的字符串。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.size();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; size) &#123;</span><br><span class="line">            <span class="keyword">while</span> (s[cur] == <span class="string">' '</span>) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> start = cur;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; size &amp;&amp; s[cur] != <span class="string">' '</span>) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = cur - start;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 拼接为新的字符串</span></span><br><span class="line">                res = s.substr(start, len) + <span class="string">" "</span> + res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理多余的空格</span></span><br><span class="line">        res.erase(res.end() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a stu
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】15. 字符串-把字符串转换成整数</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9115-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】15-字符串-把字符串转换成整数/</id>
    <published>2020-02-28T14:29:32.000Z</published>
    <updated>2020-03-01T12:33:12.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。<br>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。<br>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。<br>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。<br>在任何情况下，若函数不能进行有效的转换时，请返回 0。<br>难易程度:<strong>Medium</strong></p><p><strong>说明</strong>：</p><blockquote><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p></blockquote><p><strong>示例 1</strong>:</p><blockquote><p>输入: “42”<br>输出: 42</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: “   -42”<br>输出: -42<br>解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p></blockquote><p><strong>示例 3</strong>:</p><blockquote><p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p></blockquote><p><strong>示例 4</strong>:</p><blockquote><p>输入: “words and 987”<br>输出: 0<br>解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。</p></blockquote><p><strong>示例 5</strong>:</p><blockquote><p>输入: “-91283472332”<br>输出: -2147483648<br>解释: 数字 “-91283472332” 超过 32 位有符号整数范围。因此返回 INT_MIN (−231) 。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题并不难，循环处理每一个字符：</p><ol><li>如果是空白则跳过，直到找到第一个非空白字符；</li><li>如果第一个非空白字符为<code>-</code>则<code>sign = -1</code>；</li><li>如果第一个非空白字符为<code>+</code>则<code>sign = 1</code>；</li><li>如果第一个非空白字符不是<code>[\-+0-9]</code>则<code>return 0</code>；</li><li>遍历数字部分（ <code>res = res * 10 + (str[begin] - &#39;0&#39;)</code>），注意此处需要判断是否溢出（<code>res &gt; INT_MAX / 10 || (res == INT_MAX / 10 &amp;&amp; str[begin] &gt; &#39;7&#39;)</code>）；</li><li>如果溢出则返回最大（小）值；</li><li>返回最终结果：<code>return  res * sign;</code></li></ol><p>关键在于处理细节：</p><ol><li>符号</li><li>前导零、前导空白</li><li>数字结束处理</li><li>大数处理</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理前导空白</span></span><br><span class="line">        <span class="keyword">while</span> (str[begin] == <span class="string">' '</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理正负号</span></span><br><span class="line">        <span class="keyword">if</span> (str[begin] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[begin] == <span class="string">'+'</span>) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[begin] &lt; <span class="string">'0'</span> &amp;&amp; str[begin] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; str.size() &amp;&amp; str[begin] &gt;= <span class="string">'0'</span> &amp;&amp; str[begin] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理大数</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; str[begin] &gt; <span class="string">'7'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数值处理，整道题这行是核心</span></span><br><span class="line">            res = res * <span class="number">10</span> + (str[begin] - <span class="string">'0'</span>);</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理符号</span></span><br><span class="line">        <span class="keyword">return</span>  res * sign;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。&lt;br&gt;首先，该函数会根据需要丢弃无
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】14. 字符串- 左旋转字符串</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9114-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】14-字符串-左旋转字符串/</id>
    <published>2020-02-28T14:28:29.000Z</published>
    <updated>2020-02-28T14:34:37.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= k &lt; s.length &lt;= 10000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题可以将字符串<code>s</code>中的<code>n-&gt;0, n+1-&gt;1, ..., (n + i) % len-&gt;i</code>，即<code>res[i] = s[(n + i) % len]</code>。<br><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            res.append(<span class="number">1</span>,s[(n + i++) % len]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>相对于方法一，需要遍历整个<code>s</code>,一个更简单的方法就是将旋转看做将字符串<code>s</code>的后<code>s.size() - n</code>个字符组成的子串<code>substr2</code>和前<code>n</code>个字符组成的子串<code>substr1</code>拼接为一个新的字符串串。<br><strong>时间复杂度</strong>：O(1)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substr(n, s.size() - n) + s.substr(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/categories/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://m.fanruo.net/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】13. 数组-滑动窗口的最大值</title>
    <link href="https://m.fanruo.net/2020/02/28/%E3%80%90leetcode%E3%80%9113-%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <id>https://m.fanruo.net/2020/02/28/【leetcode】13-数组-滑动窗口的最大值/</id>
    <published>2020-02-28T14:27:16.000Z</published>
    <updated>2020-02-28T14:34:40.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p></blockquote><blockquote><p>  滑动窗口的位置                最大值<br>[1  3  -1] -3  5  3  6  7      3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p><strong>提示</strong>：</p><blockquote><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过分析，索引<code>[i - k, i)</code>之间的<code>k</code>个元素的最大值<code>max</code>的索引<code>max_index</code>存在<code>max_index &gt; i - k &amp;&amp; max_index &lt; i</code>且<code>nums[i] &gt;= nums[max_index]</code></p><ol><li>则<code>max_index = i</code>,即<code>i</code>是<code>(i - k, i]</code>之间元素最大值的<code>max_index</code></li><li>否则遍历<code>(i - k, i]</code>之间所有元素找到最大值<code>max</code>及<code>max_index</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_index &gt; i - k &amp;&amp; max_index &lt; i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt;= nums[max_index]) &#123;</span><br><span class="line">                    max_index = i; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max_index = i - k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = max_index; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt;= nums[max_index]) &#123;</span><br><span class="line">                        max_index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(nums[max_index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】12. 数组-0～n-1中缺失的数字</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9112-%E6%95%B0%E7%BB%84-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】12-数组-0～n-1中缺失的数字/</id>
    <published>2020-02-24T12:36:56.000Z</published>
    <updated>2020-02-24T12:38:54.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>:</p><blockquote><p>输入: [0,1,3]<br>输出: 2</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>1 &lt;= 数组长度 &lt;= 10000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从本题题意可以提出如下几个关键信息：</p><ol><li>数组长度为<code>n-1</code></li><li>每个数字都在范围<code>0～n-1</code>之内(一个<code>n</code>个元素)</li><li>数组是递增有序，且唯一</li></ol><p>跟进上面提取出的题意，可以得到信息：</p><ol><li>如果不缺数字的话，数字<code>i = nums[i]</code></li><li>当<code>i</code>位置的元素不是<code>i</code>,即<code>i != nums[i]</code>的时候，则有<code>j &gt; i; nums[j] &gt; j</code> 且<code>k &lt; i; nums[k] == k</code></li></ol><p>本题依旧是二分查找问题，只是调整范围的判断条件有所调整。</p><p><strong>时间复杂度</strong>：O(logN)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】11. 数组-在排序数组中查找数字</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9111-%E6%95%B0%E7%BB%84-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】11-数组-在排序数组中查找数字/</id>
    <published>2020-02-24T12:36:39.000Z</published>
    <updated>2020-02-24T12:37:27.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>统计一个数字在排序数组中出现的次数。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p></blockquote><p><strong>示例 2</strong>:</p><blockquote><p>输入: nums = [5,7,7,8,8,10], target = 6<br>输出: 0</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= 数组长度 &lt;= 50000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题是一个典型的查找问题。根据题意可以提取两点信息：</p><ol><li>数组本身是有序的</li><li>需要输出<code>target</code>出现的次数</li></ol><p>因此，本题转换成查找边界问题：</p><ol><li><code>target</code>第一次出现的位置</li><li><code>target</code>最后一次出现的位置</li></ol><p><strong>时间复杂度</strong>：O(logN)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找target第一次出现的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123; </span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">// 保证nums[left]始终小于target</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == nums.size() ||right &lt; left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> start = left;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找target最后一次出现的位置的下一个位置</span></span><br><span class="line">        right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 保证nums[left]最终是target最后一次出现的下一个位置或者数组的尾的下一个位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left - start;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】10. 数组-顺时针打印矩阵</title>
    <link href="https://m.fanruo.net/2020/02/24/%E3%80%90leetcode%E3%80%9110-%E6%95%B0%E7%BB%84-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
    <id>https://m.fanruo.net/2020/02/24/【leetcode】10-数组-顺时针打印矩阵/</id>
    <published>2020-02-24T10:45:11.000Z</published>
    <updated>2020-02-24T12:37:45.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p></blockquote><p><strong>示例 2</strong>：</p><blockquote><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题本质上一个模拟过程,设矩阵上右下左的范围一次是<code>top = 0,right = n - 1,button = m - 1,left = 0</code>：</p><ol><li><code>left-&gt;right</code>：上侧从左到右，<code>i = left; lmatrix[top][i]; i++</code>，遍历完后<code>top</code>这一行需要丢弃，<code>top++</code></li><li><code>top-&gt;button</code>：右侧从上到下，<code>i = top; matrix[i][right]; i++</code>，遍历完后<code>right</code>这一列需要丢弃，<code>right--</code></li><li><code>right-&gt;left</code>：下侧从右到左，<code>i = right; matrix[button][i]; i--</code>，遍历完后<code>button</code>这一行需要丢弃，<code>button--</code></li><li><code>button-&gt;top</code>：左侧从下到上，<code>i = button; matrix[i][left]; i++</code>，遍历完后<code>left</code>这一列需要丢弃，<code>left++</code></li></ol><p><strong>时间复杂度</strong>：O(N^2)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, button = m - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                res.push_back(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++top &gt; button) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= button; i++) &#123;</span><br><span class="line">                res.push_back(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--right &lt; left) bareak;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt;= left; i--) &#123;</span><br><span class="line">                res.push_back(matrix[button][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--button &lt; top) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = button; i &gt;= top; i--) &#123;</span><br><span class="line">                res.push_back(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;br&gt;&lt;strong&gt;难易程度&lt;/strong&gt;：easy&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】9. 数组-二维数组中的查找</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%919-%E6%95%B0%E7%BB%84-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】9-数组-二维数组中的查找/</id>
    <published>2020-02-22T15:10:42.000Z</published>
    <updated>2020-02-22T15:11:16.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>难易程度</strong>：easy</p><p><strong>示例</strong>:</p><blockquote><p>现有矩阵 matrix 如下：<br>[<br> [1,   4,  7, 11, 15],<br> [2,   5,  8, 12, 19],<br> [3,   6,  9, 16, 22],<br> [10, 13, 14, 17, 24],<br> [18, 21, 23, 26, 30]<br>]</p></blockquote><blockquote><p>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>0 &lt;= n &lt;= 1000<br>0 &lt;= m &lt;= 1000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题抓住两个点：</p><ol><li>每一行都按照从左到右递增的顺序排序</li><li>每一列都按照从上到下递增的顺序排序</li></ol><p>以上两点说明：</p><ol><li>矩阵<code>matrix</code>中小于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的左侧或者上侧，即列坐标小于<code>j</code>或者行坐标小于<code>i</code></li><li>矩阵<code>matrix</code>中大于<code>matrix[i][j]</code>的元素只能出现在该元素所在列的右侧或者下侧，即列坐标大于<code>j</code>或者行坐标大于<code>i</code></li></ol><p>我们从右上角开始遍历：</p><ol><li><code>matrix[i][j] == target</code>,返回 true</li><li><code>matrix[i][j] &gt; target</code>, 由<strong>说明1</strong>可知<code>target</code>只可能出现在左侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>i++</code></li><li><code>matrix[i][j] &lt; target</code>, 由<strong>说明2</strong>可知<code>target</code>只可能出现在下侧（<code>matrix[i][j]</code>右&amp;上侧的数据已经遍历过了），则<code>j--</code></li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【leetcode】8. 数组-数组中重复的数字</title>
    <link href="https://m.fanruo.net/2020/02/22/%E3%80%90leetcode%E3%80%918-%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://m.fanruo.net/2020/02/22/【leetcode】8-数组-数组中重复的数字/</id>
    <published>2020-02-22T15:09:39.000Z</published>
    <updated>2020-02-22T15:10:22.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>找出数组中重复的数字。<br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br><strong>难易程度</strong>：easy</p><p><strong>示例 1</strong>：</p><blockquote><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3</p></blockquote><p><strong>限制</strong>：</p><blockquote><p>2 &lt;= n &lt;= 100000</p></blockquote><blockquote><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>本题解法很多。注意两点：</p><ol><li>查找：想到随机查找（数组下标、关联容器key）</li><li>所有数字都在 0～n-1 的范围内：可以利用数据下标</li><li>找出数组中任意一个重复的数字</li></ol><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以再遍历数组的同时对每一个元素做一个标记，这个标记是可以在O(1)时间复杂度获取的，继续遍历数组，并判断元素标记，如果已经存在，则直接返回，否则改变标志。具体流程如下：</p><ol><li>创建一个<code>map&lt;int, bool&gt; ret</code></li><li>遍历数组<code>nums</code>,如果<code>ret[nums[i]]</code> 不存在，则<code>ret[nums[i]] = true</code>；如果<code>ret[nums[i]] = true</code>，则返回<code>nums[i]</code></li></ol><p><strong>tips</strong>：步骤1种使用<code>map</code>并不是最优的,也可以使用<code>set</code>。在数组元素重复的比较少的时候可以使用<code>vector</code>。</p><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(N)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; ret;<span class="comment">// 使用map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.count(nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret(nums.size(), <span class="literal">false</span>);<span class="comment">// 使用vector</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret[nums[i]] == <span class="literal">false</span>) &#123;</span><br><span class="line">                ret[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ret;<span class="comment">// 使用set</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ret.insert(nums[i]).second) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题并没限制不能改变原有数组<code>nums</code>，同时强调，所有数字都在 0～n-1 的范围内。因此，可以将元素<code>nums[i]</code>移动到<code>nums[nums[i]]</code>：</p><ol><li>当<code>nums[i] == i</code>,说明<code>i</code>位置上的元素已经是<code>i</code>了，不做任何处理，继续遍历</li><li>当<code>nums[i] == nums[nums[i]]</code>，说明<code>nums[i]</code>位置的元素已经是<code>nums[i]</code>,说明重复了，返回<code>nums[i]</code>即可</li><li>当上述两个条件都不满足的时候，交换一下</li></ol><p><strong>时间复杂度</strong>：O(N)<br><strong>空间复杂度</strong>：O(1)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == i ) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[nums[i]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[nums[i]];</span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;找出数组中重复的数字。&lt;br&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有
      
    
    </summary>
    
      <category term="leetcode" scheme="https://m.fanruo.net/categories/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/categories/leetcode/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="leetcode" scheme="https://m.fanruo.net/tags/leetcode/"/>
    
      <category term="数组" scheme="https://m.fanruo.net/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
